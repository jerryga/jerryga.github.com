<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[JerryGa's Blog]]></title>
  <link href="http://jerryga.github.com/atom.xml" rel="self"/>
  <link href="http://jerryga.github.com/"/>
  <updated>2013-09-29T17:00:29+08:00</updated>
  <id>http://jerryga.github.com/</id>
  <author>
    <name><![CDATA[JerryGa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ios7 Multitasking]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/27/ios7-multitasking/"/>
    <updated>2013-09-27T10:14:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/27/ios7-multitasking</id>
    <content type="html"><![CDATA[<p>Multitasking in ios7</p>

<p>ios7中的多任务</p>

<h2>简介</h2>

<p>在远古的ios4.0石器时代，可以使用
-beginBackgroundTaskWithExpirationHandler:来使app切换后台后，运行最多600s的时间。珍贵的10分钟，可以用来做些紧急操作，比如保存数据库、保存重要文件。eg：</p>

<pre><code>- (void) saveData
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{


    [self beginBackgroundUpdateTask];

    //self.dbData to save

    // Do something with the data

    [self endBackgroundUpdateTask];
});
</code></pre>

<p>}</p>

<pre><code>- (void) beginBackgroundUpdateTask
{
    self.backgroundUpdateTask = [[UIApplication     sharedApplication]  beginBackgroundTaskWithExpirationHandler:^{
    [self endBackgroundUpdateTask];
    }];
}

- (void) endBackgroundUpdateTask
{
    [[UIApplication sharedApplication] endBackgroundTask: self.backgroundUpdateTask];
    self.backgroundUpdateTask = UIBackgroundTaskInvalid;
}   
</code></pre>

<p>在超过系统分配的600s时间后，会调用beginBackgroundTaskWithExpirationHandler这个block。在任务结束的时候调用endBackgroundUpdateTask，并设置self.backgroundUpdateTask为UIBackgroundTaskInvalid状态。</p>

<p>ios6和之前的系统说明图：</p>

<p><img src="" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using CocoaPods to manager your third party.]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/26/using-cocoapods-to-manager-your-third-party/"/>
    <updated>2013-09-26T15:41:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/26/using-cocoapods-to-manager-your-third-party</id>
    <content type="html"><![CDATA[<h2>简介：</h2>

<p>CocoaPods主要用于负责管理iOS项目中第三方库。如果Project用了很多第三方库，那么通过CocoaPods，就不再需要手动配置、更新第三方开源库。节省很多时间。</p>

<h2>配置CocoaPods</h2>

<p>通过Mac下的ruby来安装：</p>

<pre><code>$ gem install cocoapods
$ pod setup
</code></pre>

<h2>使用CocoaPods</h2>

<p>新建名为Podfile的文件：</p>

<pre><code>platform :ios

pod 'FormatterKit'
pod 'AFNetworking', '~&gt; 0.7.0'
</code></pre>

<p>然后将此文件放到项目根目录下：</p>

<p><img src="http://jerryga.github.com/static/CocoaPods-01" alt="" /></p>

<p>然后cd到工程根目录：</p>

<pre><code>pod install
</code></pre>

<p>之后，在Podfile文件中的第三方库都下载完成并配置OK。
<strong><em>note</em></strong></p>

<ol>
<li>在打开工程的时候，需要使用CocoaPods生成的.xcworkspace文件来打开工程。</li>
<li>每次更改了Podfile文件，需要重新执行一次pod install命令。</li>
</ol>


<h2>查找库：</h2>

<p>使用pod search来查找，比如查找json库：</p>

<p><img src="http://jerryga.github.com/static/CocoaPods-02" alt="" /></p>

<h2>Example</h2>

<p> <a href="https://github.com/jerryga/TestCocoaPods.git">Example In Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios7 StatusBarHidden]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/26/ios7-statusbarhidden/"/>
    <updated>2013-09-26T15:10:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/26/ios7-statusbarhidden</id>
    <content type="html"><![CDATA[<h4>ios7:</h4>

<pre><code>//viewDidLoad

[self prefersStatusBarHidden];
    [self performSelector:@selector(setNeedsStatusBarAppearanceUpdate)];

// Add this Method
- (BOOL)prefersStatusBarHidden
{
    return YES;
}
</code></pre>

<h4>&lt; ios7</h4>

<pre><code>In info.plist add this key-value:

Key: View controller-based status bar appearance
Value: NO
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/18/block/"/>
    <updated>2013-09-18T11:23:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/18/block</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[APNS]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/17/apns/"/>
    <updated>2013-09-17T17:28:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/17/apns</id>
    <content type="html"><![CDATA[<h4>APNS</h4>

<p><img src="http://jerryga.github.com/static/apns.png" alt="" /></p>

<p>生成pem文件：</p>

<pre><code>openssl pkcs12 -clcerts -nokeys -out apns-dev-cert.pem -in apns-dev-cert.p12

openssl pkcs12 -nocerts -out apns-dev-key.pem -in apns-dev-key.p12
</code></pre>

<p>将key和许可文件合成为apns-dev.pem</p>

<pre><code>cat apns-dev-cert.pem apns-dev-key-noenc.pem &gt; apns-dev.pem
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[objc_msgSend() VS performSelector]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/13/objc-msgsend-vs-performselector/"/>
    <updated>2013-09-13T15:43:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/13/objc-msgsend-vs-performselector</id>
    <content type="html"><![CDATA[<h4>Diff</h4>

<p>两者的主要区别是：objc_msgSend不会通过编译器进行类型检查。在ARC中，如果使用performSelector可能会得到警告</p>

<pre><code>#warning：PerformSelector may cause a leak because its selector is unknown.
</code></pre>

<p>在xcode4.2 LLVM3.0的环境下,可以这样消除警告：</p>

<pre><code>#define SuppressPerformSelectorLeakWarning(Stuff) \
do { \
_Pragma("clang diagnostic push") \
_Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \
Stuff; \
_Pragma("clang diagnostic pop") \
} while (0)
</code></pre>

<p>这样使用：</p>

<pre><code>SuppressPerformSelectorLeakWarning(

            [_target performSelector:_responseSel   withObject:_sectionModel];
    );
</code></pre>

<p>使用objc_msgSend(<em>target, </em>responseSel);虽然也可以消除警告，但是由于objc_msgSend()不会进行类型检查，所以建议尽量不要这样做。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CCProgress]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/10/ccprogress/"/>
    <updated>2013-09-10T15:46:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/10/ccprogress</id>
    <content type="html"><![CDATA[<h4>进度条Progress的使用</h4>

<pre><code>CCSize size = CCDirector::sharedDirector()-&gt;getWinSize();

 CCProgressTo* p1 = CCProgressTo::create(2, 80);
//第一个参数是时间，第二个参数是表示只旋转或者伸长80%
CCSprite *progressSprite = CCSprite::create("RedExpProgressBar.png");
CCProgressTimer* pt = CCProgressTimer::create(progressSprite);
//两种类型kCCProgressTimerTypeRadial和kCCProgressTimerTypeBar
pt-&gt;setType(kCCProgressTimerTypeBar);
pt-&gt;setMidpoint(CCPointMake(0, 0));
pt-&gt;setBarChangeRate(CCPointMake(1, 0));
addChild(pt);
pt-&gt;setPosition(ccp(size.width / 3, size.height / 2));
pt-&gt;runAction(CCRepeatForever::create(p1));
</code></pre>

<p>函数说明：</p>

<p>setMidpoint()函数是设置进度条的起始点，（0,y）表示最左边，（1,,y）表示最右边，（x,1）表示最上面，（x,0）表示最下面。setBarChangeRate()函数是用来设置进度条动画方向的，（1,0）表示横方向，（0,1）表示纵方向。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSRunLoop And NSThread]]></title>
    <link href="http://jerryga.github.com/blog/2013/09/09/nsrunloop-and-nsthread/"/>
    <updated>2013-09-09T16:55:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/09/09/nsrunloop-and-nsthread</id>
    <content type="html"><![CDATA[<h4>NSRunLoop的特性：</h4>

<ol>
<li>每个线程都有一个Run Loop，主线程的Run Loop会在App运行时自动运行，子线程中需要手动运行。</li>
<li>每个Run Loop都会以一个模式mode来运行，可以使用NSRunLoop的- (BOOL)runMode:(NSString <em>)mode beforeDate:(NSDate </em>)limitDate 方法运行在某个特定模式mode。</li>
<li>Run Loop的处理两大类事件源：Timer Source和Input Source(包括performSelector***方法簇、Port或者自定义Input Source)，每个事件源都会绑定在Run Loop的某个特定模式mode上，而且只有RunLoop在这个模式运行的时候才会触发该Timer和Input Source。</li>
<li>如果没有任何事件源添加到Run Loop上，Run Loop就会立刻exit。</li>
</ol>


<h4>运行模式Mode</h4>

<ol>
<li>NSDefaultRunLoopMode: 默认的运行模式.</li>
<li>NSRunLoopCommonModes: 是一组常用的模式集合,在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode. <strong><em>注意</em></strong>：让Run Loop运行在NSRunLoopCommonModes下是没有意义的，因为一个时刻Run Loop只能运行在一个特定模式下，而不可能是个模式集合。</li>
<li>UITrackingRunLoopMode: 用于跟踪触摸事件触发的模式（例如UIScrollView上下滚动），主线程当触摸事件触发时会设置为这个模式，可以用来在控件事件触发过程中设置Timer。</li>
<li>GSEventReceiveRunLoopMode: 用于接受系统事件，属于内部的Run Loop模式。</li>
<li>自定义Mode:在coreFoundation中通过CFRunLoopAddCommonMode方法添加自定义Mode到NSRunLoopCommonModes中。</li>
</ol>


<h4>事件源</h4>

<p>两类：Timer Source和Input Source(包括-performSelector:API调用簇，Port Input Source、自定义Input Source)
图表：</p>

<p><img src="http://jerryga.github.com/static/runLoop.png" alt="" /></p>

<p>从上图可以看出Run Loop就是处理事件的一个循环，不同的是Timer Source事件处理后不会使Run Loop结束，而Input Source事件处理后会让Run Loop退出。因此你需要自己的一个Loop去不断运行Run Loop来处理事件，就像本文开头的示例那样。</p>

<p>1) Timer Souce就是创建Timer添加到Run Loop中。需要注意的是scheduledTimerWith开头生成的Timer会自动帮你以默认NSDefaultRunLoopMode模式加载到当前的Run Loop中，而其他接口生成的Timer则需要你手动使用-addTimer:forMode添加到Run Loop中。需要额外注意的是Timer的触发不会让Run Loop返回。(Timer sources deliver events to their handler routines but do not cause the run loop to exit.) 。
2) Input Source中的-performSelector:API调用簇方法，有以下这些接口：</p>

<pre><code>performSelectorOnMainThread:withObject:waitUntilDone:
performSelectorOnMainThread:withObject:waitUntilDone:modes:

performSelector:onThread:withObject:waitUntilDone:
performSelector:onThread:withObject:waitUntilDone:modes:

performSelector:withObject:afterDelay:
performSelector:withObject:afterDelay:inModes:

cancelPreviousPerformRequestsWithTarget:
cancelPreviousPerformRequestsWithTarget:selector:object:
</code></pre>

<p>3) Port Input Source：可以用NSMachPort作为线程之间的通讯通道。例如在主线程创建子线程时传入一个NSPort对象，这样主线程就可以和这个子线程通讯啦，如果要实现双向通讯，那么子线程也需要回传给主线程一个NSPort。NSPort的子类除了NSMachPort，还可以使用NSMessagePort或者Core Foundation中的CFMessagePortRef。
注意：虽然有这么棒的方式实现线程间通讯方式，但是估计是由于危及iOS的Sandbox沙盒环境，所以这些API都是私有接口，如果你用到NSPortMessage，XCode会提示&#8217;NSPortMessage&#8217; for instance message is a forward declaration。</p>

<p>4) 自定义Input Source：
向Run Loop添加自定义Input Source只能使用Core Foundation的接口：CFRunLoopSourceCreate创建一个source，CFRunLoopAddSource向Run Loop中添加source，CFRunLoopRemoveSource从Run Loop中删除source，CFRunLoopSourceSignal通知source，CFRunLoopWakeUp唤醒Run Loop。
Apple官方文档提供了一个自定义Input Source使用模式。</p>

<p><img src="http://jerryga.github.com/static/runLoop001.png" alt="" /></p>

<p>主线程持有包含子线程的Run Loop和Source的context对象，还有一个用于保存需要运行操作的数据buffer。主线程需要子线程干活时，首先将需要的操作数据添加到数据buffer，然后通知source，唤醒子线程Run Loop（因为子线程可能正在sleep状态，CFRunLoopWakeUp唤醒Run Loop可以通知线程醒来干活），由于子线程也持有这个source和数据buffer，因此在触发唤醒时可以使用这个数据buffer的数据来执行相关操作（需要注意数据buffer访问时的同步）。</p>

<h4>Run Loop的Observer</h4>

<p>Core Foundation层的接口可以定义一个Run Loop的观察者在Run Loop进入以下某个状态时得到通知：</p>

<ol>
<li>Run loop的进入</li>
<li>Run loop处理一个Timer的时刻</li>
<li>Run loop处理一个Input Source的时刻</li>
<li>Run loop进入睡眠的时刻</li>
<li>Run loop被唤醒的时刻，但在唤醒它的事件被处理之前</li>
<li><p>Run loop的终止
Observer的创建以及添加到Run Loop中需要使用Core Foundation的接口：</p>

<pre><code>  CFRunLoopObserverContext  context = {0, (__bridge void *)(self), NULL, NULL, NULL};
  CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopBeforeTimers, YES, 0, &amp;myRunLoopObserver, &amp;context);
  if (observer)
  {
  CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer,
                           kCFRunLoopCommonModes);
                                                          }
</code></pre>

<p>   首先创建Observer的context，然后调用Core Foundation方法CFRunLoopObserverCreate创建Observer，再加入到当前线程的Run Loop中，注意CFRunLoopObserverCreate方法的第二个参数是Observer观察类型，有如下几种：</p>

<pre><code>   /* Run Loop Observer Activities */
   typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
   kCFRunLoopEntry = (1UL &lt;&lt; 0),
   kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),
   kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),
   kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),
   kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),
   kCFRunLoopExit = (1UL &lt;&lt; 7),
   kCFRunLoopAllActivities = 0x0FFFFFFFU
       };
</code></pre></li>
</ol>


<p>对应Run Loop的各种事件，kCFRunLoopAllActivities比较特殊，可以观察所有事件。</p>

<h4>总结</h4>

<p>Run Loop就是一个处理事件源的循环，你可以控制这个Run Loop运行多久，如果当前没有事件发生，Run Loop会让这个线程进入睡眠状态(避免再浪费CPU时间)，如果有事件发生，Run Loop就处理这个事件。Run Loop处理事件和发送给Observer通知的流程如下：</p>

<ol>
<li>进入Run Loop运行，此时会通知观察者进入Run Loop；</li>
<li>如果有Timer即将触发时，通知观察者；</li>
<li>如果有非Port的Input Sourc即将e触发时，通知观察者；</li>
<li>触发非Port的Input Source事件源；</li>
<li>如果基于Port的Input Source事件源即将触发时，立即处理该事件，跳转到步骤9；</li>
<li>通知观察者当前线程将进入休眠状态；</li>
<li>将线程进入休眠状态直到有以下事件发生：基于Port的Input Source被触发、Timer被触发、Run Loop运行时间到了过期时间、Run Loop被唤醒。</li>
<li>通知观察者线程将要被唤醒。</li>
<li>处理被触发的事件：
如果是用户自定义的Timer，处理Timer事件后重新启动Run Loop进入步骤2；
如果线程被唤醒又没有到过期时间，则进入步骤2；
如果是其他Input Source事件源有事件发生，直接处理这个事件；</li>
<li>到达此步骤说明Run Loop运行时间到期，或者是非Timer的Input Source事件被处理后，Run Loop将要退出，退出前通知观察者线程已退出。</li>
</ol>


<p>什么时候需要用到Run Loop？官方文档的建议是：</p>

<ol>
<li>需要使用Port或者自定义Input Source与其他线程进行通讯。</li>
<li>需要在线程中使用Timer。</li>
<li>需要在线程上使用performSelector方法。</li>
<li>需要让线程执行周期性的工作。</li>
<li>我个人在开发中遇到的需要使用Run Loop的情况有：</li>
<li>使用自定义Input Source和其他线程通信</li>
<li>子线程中使用了定时器</li>
<li>使用任何performSelector到子线程中运行方法</li>
<li>使用子线程去执行周期性任务</li>
<li>NSURLConnection在子线程中发起异步请求</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCD]]></title>
    <link href="http://jerryga.github.com/blog/2013/08/30/gcd/"/>
    <updated>2013-08-30T11:25:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/08/30/gcd</id>
    <content type="html"><![CDATA[<h3>What is GCD?</h3>

<p>Grand Central Dispatch 简称为GCD，这是一套底层api，提供了一种新的方法来进行并发程序编写。类似于NSOperationQueue，允许程序将多个任务切分为多个单一任务然后提交到工作队列来并发地或者串行地执行。GCD相对于NSOperationQueue更底层，更高效，并且它不是Cocoa框架的一部分。</p>

<h3>GCD的功能如下：</h3>

<ol>
<li>正如开头所说，GCD允许将多个任务切分为多个单一任务并发或者串行地执行。这个应该是使用GCD最多的地方。</li>
<li>可以设置句柄来响应文件描述符。（如可以通过GCD来读取文件，并获得读取进度，这个在JerryGa的github有相关Demo）</li>
<li>可以通过mach ports来进行进程间的通讯。</li>
<li>计时器、信号量、用户生成事件。</li>
</ol>


<h3>GCD的优势：</h3>

<ol>
<li><strong><em>简单易用</em></strong>。由于GCD基于work unit而非像thread那样基于运算，所以GCD可以控制诸如等待任务结束、监视文件描述符、周期执行代码以及工作挂起等任务。基于block的血统导致它能极为简单得在不同代码作用域之间传递上下文。</li>
<li><strong><em>效率</em></strong>: GCD被实现得如此轻量和优雅，使得它在很多地方比之专门创建消耗资源的线程更实用且快速。这关系到易用性：导致GCD易用的原因有一部分在于你可以不用担心太多的效率问题而仅仅使用它就行了。</li>
<li><strong><em>性能</em></strong>: GCD自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。</li>
</ol>


<h3>Dispatch Objects</h3>

<p>Dispatch Object也是使用引用计数的，使用dispatch_release和dispatch_retain函数来操作dispatch object进行内存管理。但是dispatch不参与垃圾回收机制（ARC）。</p>

<h3>Dispatch Queues</h3>

<p>并行概念：同一时间执行多个不同任务。
串行概念：同一时间只能执行单一任务。</p>

<p>GCD有三种队列：</p>

<ol>
<li>main queue:串行队列。提交到此queue的任务会在主线程中执行。使用dispatch_get_main_queue()来获取.</li>
<li><p>global queue：全局队列。是并发队列。有三个优先级：</p>

<pre><code>DISPATCH_QUEUE_PRIORITY_HIGH 2 //最高
DISPATCH_QUEUE_PRIORITY_DEFAULT 0 //默认
DISPATCH_QUEUE_PRIORITY_LOW (-2) //低级
DISPATCH_QUEUE_PRIORITY_BACKGROUND           INT16_MIN( Available in iOS 5.0 and later.)//某些磁盘读写操作可以设置此优先级。
</code></pre>

<p> 获取全局队列代码如下：                                       dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p></li>
<li><p>自己创建的队列。有两方式：串行、并行。串行可以用来实现同步机制，类似线程锁。EG：</p>

<p> <strong><em>串行</em></strong></p>

<pre><code>DISPATCH_QUEUE_SERIAL FIFO
dispatch_queue_t serialQueue =   dispatch_queue_create("com.Test.gcd", DISPATCH_QUEUE_SERIAL);

dispatch_async(serialQueue, ^{
 NSLog(@"Task1*** ");
 });

 dispatch_async(serialQueue, ^{
 NSLog(@"Task2***");
 });
dispatch_async(serialQueue, ^{
 NSLog(@"Task3*** ");
 });
</code></pre>

<p>测试输出结果如下：</p>

<pre><code>  2013-08-30 12:20:19.684 GCDTestPro[3882:1303] Task1*** 
  2013-08-30 12:20:19.685 GCDTestPro[3882:1303] Task2***
  2013-08-30 12:20:19.686 GCDTestPro[3882:1303] Task3***
</code></pre>

<p>  <strong><em>并行</em></strong></p>

<pre><code>DISPATCH_QUEUE_CONCURRENT

  dispatch_queue_t asyQueue = dispatch_queue_create("com.Test.gcd", DISPATCH_QUEUE_CONCURRENT);

  dispatch_async(asyQueue, ^{
  NSLog(@"Task1*** ");
  });
  dispatch_async(asyQueue, ^{
  NSLog(@"Task2***");
  });
  dispatch_async(asyQueue, ^{
  NSLog(@"Task3*** ");
  });
</code></pre>

<p>测试输出结果如下：</p>

<pre><code>2013-08-30 12:27:34.523 GCDTestPro[4043:1b03] Task2***
2013-08-30 12:27:34.523 GCDTestPro[4043:1303] Task1*** 
2013-08-30 12:27:34.523 GCDTestPro[4043:3d13] Task3*** 
</code></pre></li>
</ol>


<p>从测试结果可以看出：串行队列是同步机制。按照先入先出的原则依顺序执行。而异步队列的执行顺序是无序的。所以，对于自定义队列有两种：FIFO、ASY，由创建队列时的dispatch_queue_attr_t决定。注意：DISPATCH_QUEUE_CONCURRENT是在4.3以后才可以使用。</p>

<h3>锁</h3>

<p>使用GCD的同步机制可以用来代替传统多线程编程中的Lock。</p>

<p>eg：
传统编程中我们可能这样做：</p>

<pre><code>- (void)setStatus:(Status)status {
@synchronized(self) {
    _status = status;
}
}
</code></pre>

<p>或者：</p>

<pre><code>- (void)setStatus:(Status)status {
[_lock lock];
_status = status;
[_lock unlock];
}
</code></pre>

<p>用GCD来代替：</p>

<pre><code>- (void)setStatus:(Status)status {
dispatch_sync(_lockQueue, ^{
    _status = status;
}
}

- (void)setStatus:(Status)status {
dispatch_async(_lockQueue, ^{
    _status = status;
}
}
</code></pre>

<p>async是异步处理
sync 是同步处理，可以从 传统的 “互斥” 来理解。因为在设置obj的时候，可能有一大堆数据需要运算赋值，所以异步执行。</p>

<h3>终止Queue</h3>

<p>在GCD API中，并没有提供真正的cancel当前queue的功能（如果想得到更多的queue的控制权，建议用NSOperationQueue） ，在api中有dispatch_suspend（）函数（必须和dispatch_resume调用次数一致），这个函数是挂起queue，提交到queue的block可能已经执行了，在调用dispatch_suspend（）之前，所以dispatch_suspend（）并不能起到cancel当前正在运行task的作用。</p>

<p>现提供一种方法来cancel正在运行的task的方式：</p>

<pre><code>#import "GCDManager.h"

@interface GCDManager ()
{
    BOOL isCanceled;
    dispatch_queue_t myQueue;
}
@end

@implementation GCDManager

- (void) cancelCurrentGCD {
isCanceled = YES;
}

- (id)init {
    if (self = [super init]) {
        isCanceled = NO;
        myQueue = 
    dispatch_queue_create("com.GCDTestPro.myQueue",             DISPATCH_QUEUE_SERIAL);
    }
    return self;
}

- (void)doSomeWorkOnGCD {
    dispatch_async(myQueue, ^{
        for (int i = 0; i &lt; 1000; ++i) {
            if (!isCanceled) {
                NSLog(@"i %d",i);
            }
        }
    });
}

- (void)dealloc {
    dispatch_release(myQueue);
    [super dealloc];
}
</code></pre>

<p>测试用例：</p>

<pre><code>GCDManager *manager = [[GCDManager alloc] init];
[manager doSomeWorkOnGCD];
[manager performSelector:@selector(cancelCurrentGCD) withObject:nil afterDelay:0.5];
[manager release];
</code></pre>

<p>测试结果：</p>

<pre><code>2013-09-03 16:24:25.139 GCDTestPro[6066:1303] i 0
                    ……
2013-09-03 16:24:25.638 GCDTestPro[6066:1303] i 607
2013-09-03 16:24:25.638 GCDTestPro[6066:1303] i 608
2013-09-03 16:24:25.639 GCDTestPro[6066:1303] i 609
2013-09-03 16:24:25.639 GCDTestPro[6066:1303] i 610
2013-09-03 16:24:25.639 GCDTestPro[6066:1303] i 611
</code></pre>

<p>结果说明：</p>

<p>可以看出，在延迟0.5s之后，task就终止到了i=611的时候。如果不调用
cancelCurrentGCD，那会一直到i=999，task才回终止。</p>

<h3>Dispatch group</h3>

<p>dispatch group可以将多个要执行的block封装成一组，当这些block完成时，监测到发出的消息。</p>

<p>测试用例：</p>

<pre><code>dispatch_group_t group = dispatch_group_create();

dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 1");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 2");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 3");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 4");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 5");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 6");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 7");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 8");
});
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

NSLog(@"All task in queue finished");
</code></pre>

<p>输出结果：</p>

<pre><code>2013-09-04 10:45:49.213 GCDTestPro[958:1c03] This is Task 2
2013-09-04 10:45:49.213 GCDTestPro[958:1e03] This is Task 3
2013-09-04 10:45:49.213 GCDTestPro[958:4103] This is Task 4
2013-09-04 10:45:49.213 GCDTestPro[958:1303] This is Task 1
2013-09-04 10:45:49.216 GCDTestPro[958:1c03] This is Task 5
2013-09-04 10:45:49.216 GCDTestPro[958:1e03] This is Task 6
2013-09-04 10:45:49.216 GCDTestPro[958:4103] This is Task 7
2013-09-04 10:45:49.216 GCDTestPro[958:1303] This is Task 8
2013-09-04 10:45:49.218 GCDTestPro[958:c07] All task in queue finished
</code></pre>

<p>这样的话，一直会等到在group中的所有task执行完，会阻塞当前thread。api提供了相关方法来代替此种方式：dispatch_group_notify</p>

<p>测试用例：</p>

<pre><code>dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 1");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 2");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 3");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 4");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 5");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 6");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 7");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 8");
});
dispatch_group_notify(group, queue, ^{
    NSLog(@"All task in queue finished");
});
NSLog(@"I am out of group");
</code></pre>

<p>输出结果：</p>

<pre><code>2013-09-04 10:51:34.256 GCDTestPro[1044:c07] I am out of group
2013-09-04 10:51:34.256 GCDTestPro[1044:1303] This is Task 1
2013-09-04 10:51:34.257 GCDTestPro[1044:3d13] This is Task 3
2013-09-04 10:51:34.256 GCDTestPro[1044:1b03] This is Task 2
2013-09-04 10:51:34.257 GCDTestPro[1044:4003] This is Task 4
2013-09-04 10:51:34.260 GCDTestPro[1044:4103] This is Task 5    
2013-09-04 10:51:34.261 GCDTestPro[1044:1303] This is Task 6
2013-09-04 10:51:34.261 GCDTestPro[1044:4303] This is Task 7
2013-09-04 10:51:34.262 GCDTestPro[1044:4403] This is Task 8
2013-09-04 10:51:34.267 GCDTestPro[1044:4403] All task in queue finished
</code></pre>

<h4>Dispatch_group_enter的使用：</h4>

<pre><code>dispatch_group_t group = dispatch_group_create();

MyCoreDataObject *coreDataObject;

dispatch_group_enter(group);
AFHTTPRequestOperation *operation1 =    [[AFHTTPRequestOperation alloc] initWithRequest:request1];
[operation1 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
coreDataObject.attribute1 = responseObject;
sleep(5);
dispatch_group_leave(group);
}];
[operation1 start];

dispatch_group_enter(group);
AFHTTPRequestOperation *operation2 = [[AFHTTPRequestOperation alloc] initWithRequest:request1];
[operation2 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
coreDataObject.attribute2 = responseObject;
sleep(10);
dispatch_group_leave(group);
}];
[operation2 start];

dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);

[context save:nil];
</code></pre>

<h3>Dispatch_apply</h3>

<p>定义：</p>

<pre><code>dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));
</code></pre>

<p>参数 iterations 表示迭代的次数，void (<sup>block)(size_t)</sup> 是 block 循环体。</p>

<p>Des：调用单一block多次，并平行运算，然后等待所有运算结束</p>

<p>测试用例：</p>

<pre><code>   NSMutableArray *testArray = [[NSMutableArray alloc] init];
for (int i = 0; i &lt; 10; ++i) {
    [testArray addObject:[NSString stringWithFormat:@"%d",i]];
}
int count = [testArray count];
__block int sum = 0;
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
    sum += [[testArray objectAtIndex:i] integerValue];
    NSLog(@"sum is %d",sum);
});
NSLog(@"I am out of apply");
</code></pre>

<p>测试结果：</p>

<pre><code>2013-09-05 10:06:28.285 GCDTestPro[738:1b03] sum is 1
2013-09-05 10:06:28.285 GCDTestPro[738:4003] sum is 4
2013-09-05 10:06:28.285 GCDTestPro[738:1303] sum is 1
2013-09-05 10:06:28.285 GCDTestPro[738:c07] sum is 6
2013-09-05 10:06:28.287 GCDTestPro[738:1b03] sum is 10
2013-09-05 10:06:28.287 GCDTestPro[738:4003] sum is 15
2013-09-05 10:06:28.287 GCDTestPro[738:c07] sum is 28
2013-09-05 10:06:28.287 GCDTestPro[738:1303] sum is 21
2013-09-05 10:06:28.289 GCDTestPro[738:1b03] sum is 36
2013-09-05 10:06:28.289 GCDTestPro[738:4003] sum is 45
2013-09-05 10:06:28.290 GCDTestPro[738:c07] I am out of apply
</code></pre>

<p>从测试结果可以看出，对于sum的操作是并行运算的。而用for循环测用例以及测试结果如下：</p>

<pre><code> NSMutableArray *testArray = [[NSMutableArray alloc] init];
for (int i = 0; i &lt; 10; ++i) {
    [testArray addObject:[NSString stringWithFormat:@"%d",i]];
}
int count = [testArray count];
int sum = 0;
for (int i = 0; i &lt; count; ++i) {
    sum += [[testArray objectAtIndex:i] integerValue];
    NSLog(@"sum is %d",sum);
}
NSLog(@"I am out of for loop");
</code></pre>

<p>测试结果:</p>

<pre><code>2013-09-05 10:10:02.770 GCDTestPro[783:c07] sum is 0
2013-09-05 10:10:02.771 GCDTestPro[783:c07] sum is 1
2013-09-05 10:10:02.771 GCDTestPro[783:c07] sum is 3
2013-09-05 10:10:02.771 GCDTestPro[783:c07] sum is 6
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 10
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 15
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 21
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 28
2013-09-05 10:10:02.773 GCDTestPro[783:c07] sum is 36
2013-09-05 10:10:02.773 GCDTestPro[783:c07] sum is 45
2013-09-05 10:10:02.773 GCDTestPro[783:c07] I am out of for loop
</code></pre>

<p><strong><em>需要明智地使用这项技术，因为dispatch queue的开销虽然非常小，但仍然存在，循环代码必须拥有足够的工作量，才能忽略掉dispatch queue的这些开销。</em></strong></p>

<p>因为dispatch_apply会阻塞当前线程，如果想要在后台运行，用dispatch_async提交到queue即可：</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_async(queue, ^{
    dispatch_apply(count, queue, ^(size_t i) {
        sum += [[testArray objectAtIndex:i] integerValue];
        NSLog(@"sum is %d",sum);
    });
});
</code></pre>

<h3>Dispatch Source</h3>

<p>dispatch source就像&#8221;WatchDog&#8221;，监视某些事件，当事件发生时，自动将一个block放入一个queue队列中执行。</p>

<p>事件类型：</p>

<pre><code> *  DISPATCH_SOURCE_TYPE_DATA_ADD:        n/a
 *  DISPATCH_SOURCE_TYPE_DATA_OR:         n/a
 *  DISPATCH_SOURCE_TYPE_MACH_SEND:       mach port (mach_port_t)
 *  DISPATCH_SOURCE_TYPE_MACH_RECV:       mach port (mach_port_t)
 *  DISPATCH_SOURCE_TYPE_PROC:            process identifier (pid_t)
 *  DISPATCH_SOURCE_TYPE_READ:            file descriptor (int)
 *  DISPATCH_SOURCE_TYPE_SIGNAL:          signal number (int)
 *  DISPATCH_SOURCE_TYPE_TIMER:           n/a
 *  DISPATCH_SOURCE_TYPE_VNODE:           file descriptor (int)
 *  DISPATCH_SOURCE_TYPE_WRITE:           file descriptor (int)
</code></pre>

<p>Example：</p>

<p>计时器类型：（DISPATCH_SOURCE_TYPE_TIMER）</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(
                                DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    // create our timer source
   dispatch_source_t _timer = dispatch_source_create(
                       DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
                       queue);

    // set the time to fire (we're only going to fire once,
    // so just fill in the initial time).
    dispatch_source_set_timer(_timer,
           dispatch_time(DISPATCH_TIME_NOW, timeout * NSEC_PER_SEC),
           DISPATCH_TIME_FOREVER, 0);

    // Hey, let's actually do something when the timer fires!
    dispatch_source_set_event_handler(_timer, ^{
        NSLog(@"WATCHDOG: task took longer than %f seconds",
                timeout);
        // ensure we never fire again
        dispatch_source_cancel(_timer);
    });

    // now that our timer is all set to go, start it
    dispatch_resume(_timer);
</code></pre>

<p>读取文件类型：（DISPATCH_SOURCE_TYPE_READ）</p>

<pre><code> const char* fileName = [[[NSBundle mainBundle] pathForResource:@"Test" ofType:@"txt"] UTF8String];
int fd = open(fileName, O_NONBLOCK|O_RDONLY);    //设置type为读取
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, fd, 0, dispatch_get_main_queue());

dispatch_source_set_event_handler(source, ^{
    //每次读取的buffer
    char buffer[1024];
    //余下的size
    size_t estimatedLength = dispatch_source_get_data(source);
    //读取size
    ssize_t bytesRead = read(fd, buffer, MIN(1024, estimatedLength));
    if (bytesRead &lt; 0) {
        if (errno != EAGAIN) {
            printf("Unexpected error!");
            abort();
        }
    } else if (bytesRead &gt; 0) {
        printf("Got %ld bytes of data.%ld\n", bytesRead,estimatedLength);
    } else {
        printf("EOF encountered!\n");
        dispatch_source_cancel(source);
    }
});

dispatch_source_set_cancel_handler(source, ^{
    printf("Cancel handler was called.\n");
    close(fd);
    dispatch_release(source);
});

dispatch_resume(source);
</code></pre>

<p>事件联结：</p>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());
dispatch_source_set_event_handler(source, ^{
    [progressIndicator incrementBy:dispatch_source_get_data(source)];
});
dispatch_resume(source);

dispatch_apply([array count], globalQueue, ^(size_t index) {
    // do some work on data at index
    dispatch_source_merge_data(source, 1);
});
    dispatch_resume(source);
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MarkDown语法说明]]></title>
    <link href="http://jerryga.github.com/blog/2013/08/30/markdownyu-fa-shuo-ming/"/>
    <updated>2013-08-30T11:12:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/08/30/markdownyu-fa-shuo-ming</id>
    <content type="html"><![CDATA[<p>Link: <a href="http://wowubuntu.com/markdown/#overview">markDown</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Log]]></title>
    <link href="http://jerryga.github.com/blog/2013/08/29/ruby-log/"/>
    <updated>2013-08-29T23:11:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/08/29/ruby-log</id>
    <content type="html"><![CDATA[<h3>markdown语法快速成文，git与github实时保存，jekyll或octopress实时成书或者showoff实时成ppt。入门略有门槛，但是习惯了，写作效率会好很多。以下以octopress为例，进行说明。</h3>

<h2>配置个人github账号:</h2>

<h3>登陆github，创建一个个人账号。假设叫做：rubyonchina。</h3>

<h3>然后回到ubuntu或者Mac里面，仍然是在终端里面，输入：</h3>

<h3>[[ -f ~/.ssh/id_rsa.pub ]] || ssh-keygen -t rsa</h3>

<h3>按照默认提示一路确认，生成密钥之后，将生成的信息复制到github页面中，如下所示：[[ -f ~/.ssh/id_rsa.pub ]] &amp;&amp; cat ~/.ssh/id_rsa.pub | xclip</h3>

<h3>然后在浏览器中打开页面：</h3>

<h3>https://github.com/account/ssh</h3>

<h3>点击，Add another public key，粘贴前面步骤复制的信息，请格外注意，不要在Title中填写内容，直接将复制的内容粘贴到Key中，然后点击：Add Key即可。</h3>

<h2>配置octopress个人博客</h2>

<h3>cd ~/dev/</h3>

<h3>git clone git://github.com/imathis/octopress.git rubyonchina.github.com</h3>

<h3>cd ~/dev/rubyonchina.github.com</h3>

<h3>修改默认的.rvmrc文件的内容为：</h3>

<h3>rvm use 1.9.2@rails31</h3>

<h3>安装相应的gem:</h3>

<h3>bundle update</h3>

<h3>然后生成模版文件：</h3>

<h3>rake install</h3>

<h2>分发到github上。</h2>

<h3>分发之前，假设你已经注册用户名为rubyonchina的github.com账号，已经创建名为rubyonchina.github.com项目。</h3>

<h3>cd ~/dev/rubyonchina.github.com</h3>

<h3>git remote add rubyonchina git@github.com:rubyonchina/rubyonchina.github.com.git</h3>

<h2>新增一篇测试博客：</h2>

<h3>rake new_post[&#8220;post title&#8221;]</h3>

<h3>生成静态站点：</h3>

<h3>rake generate</h3>

<h3>配置octopress与github的连接：</h3>

<h3>rake setup_github_pages</h3>

<h3>按照提示填入你的github项目网址，比如，本示例是：</h3>

<h3>git@github.com:rubyonchina/rubyonchina.github.com.git</h3>

<h3>分发到github上：</h3>

<h3>rake deploy</h3>

<h3>第一次运行时，会询问是否建立对github的授权，输入：yes。然后将站点更新的内容推送到github上。</h3>

<h3>git push -u rubyonchina master</h3>

<h3>尝试浏览，</h3>

<h3>http://rubyonchina.github.com</h3>

<h3>OK！成功！然后，此时，再创建一个新的github的source分支，用于保存写作的md源文件等。</h3>

<h3>git add .</h3>

<h3>git commit -m &#8220;some changes&#8221;</h3>

<h3>git push rubyonchina source</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alipay]]></title>
    <link href="http://jerryga.github.com/blog/2013/08/29/alipay/"/>
    <updated>2013-08-29T23:03:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/08/29/alipay</id>
    <content type="html"><![CDATA[<h3>在ios支付宝相关测试中：报错：<strong><em>rsa_private read error : private key is NULL</em></strong>###原因：私钥没有转成PKCS8####解决方法：</h3>

<p>1.在RSADataSigner.m文件中 搜索代码 [result appendString:@&#8221;&#8212;&#8211;BEGIN PRIVATE KEY&#8212;&#8211;\n&#8221;]; 将其改成 [result appendString:@&#8221;&#8212;&#8211;BEGIN RSA PRIVATE KEY&#8212;&#8211;\n&#8221;];
2.在RSADataSigner.m文件中 搜索代码 [result appendString:@&#8221;\n&#8212;&#8211;END PRIVATE KEY&#8212;&#8211;&#8221;]; 将其改成 [result appendString:@&#8221;\n&#8212;&#8211;END RSA PRIVATE KEY&#8212;&#8211;&#8221;];</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ios的三维透视投影（转|卢克）]]></title>
    <link href="http://jerryga.github.com/blog/2013/05/27/iosde-san-wei-tou-shi-tou-ying-%28zhuan-%7Clu-ke-%29/"/>
    <updated>2013-05-27T17:13:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/05/27/iosde-san-wei-tou-shi-tou-ying-(zhuan-|lu-ke-)</id>
    <content type="html"><![CDATA[<p>一.概述
在iOS中使用CATransform3D这个结构体来表示三维的齐次坐标变换矩阵. 齐次坐标是一种坐标的表示方法，n维空间的坐标需要用n+1个元素的坐标元组来表示,在Quartz 2D Transform中就有关于齐次坐标的应用,那边是关于二维空间的变换，其某点的齐次坐标的最后一个元素始终设置为1。使用齐次坐标而不是简单的数学坐标是为了方便图形进行仿射变换，仿射变换可以通过仿射变换矩阵来实现，3D的仿射变换可以实现诸如 平移(translation)，旋转(rotation),缩放(scaling),切变(shear)等变换。如果不用齐次坐标那么进行坐标变换可能就涉及到两种运算了，加法（平移）和乘法（旋转，缩放），而使用齐次坐标以及齐次坐标变换矩阵后只需要矩阵乘法就可以完成一切了。上面的这些如果需要深入了解就需要去学习一下图形变换的相关知识，自己对矩阵的乘法进行演算。
iOS中的CALayer的3D本质上并不能算真正的3D(其视点即观察点或者所谓的照相机的位置是无法变换的),而只是3D在二维平面上的投影，投影平面就是手机屏幕也就是xy轴组成的平面(注意iOS中为左手坐标系)，那么视点的位置是如何确定的呢？可以通过CATransform3D中的m34来间接指定， m34 = -1/z,其中z为观察点在z轴上的值,而Layer的z轴的位置则是通过anchorPoint来指定的，所谓的anchorPoint(锚点)就是在变换中保持不变的点，也就是某个Layer在变换中的原点,xyz三轴相交于此点。在iOS中，Layer的anchorPoint使用unit coordinate space来描述，unit coordinate space无需指定具体真实的坐标点而是使用layer bounds中的相对位置，下图展示了一个Layer中的几个特殊的锚点,</p>

<p><img src="http://jerryga.github.com/static/7525485756_6782ed8ce6.png" alt="" /></p>

<p>m34 = -1/z中，当z为正的时候，是我们人眼观察现实世界的效果，即在投影平面上表现出近大远小的效果，z越靠近原点则这种效果越明显，越远离原点则越来越不明显，当z为正无穷大的时候，则失去了近大远小的效果，此时投影线垂直于投影平面，也就是视点在无穷远处，CATransform3D中m34的默认值为0，即视点在无穷远处.
还有一个需要说明一下的就是齐次坐标到数学坐标的转换 通用的齐次坐标为 (a, b, c, h),其转换成数学坐标则为 (a/h, b/h, c/h).
二.代数解释
假设一个Layer anchorPoint为默认的 (0.5, 0.5 ), 其三维空间中一个A点 (6, 0, 0)，m34 = -1/1000.0, 则此点往z轴负方向移动10个单位之后，则在投影平面上看到的点的坐标是多少呢？
A点使用齐次坐标表示为 (6, 0, 0, 1)
QuartzCore框架为我们提供了函数来算出所需要的矩阵，</p>

<pre><code>CATransform3D transform = CATransform3DIdentity;
transform.m34 = -1/1000.0;
transform = CATransform3DTranslate(transform, 0, 0, -10);
</code></pre>

<p>计算出来的矩阵为</p>

<p>{ 1,    0,    0,     0; <br/>
  0,    1,    0,     0; <br/>
  0,    0,    1,     -0.001; <br/>
  0,    0,  -10,    1.01;    <br/>
} <br/>
其实上面的变换矩阵本质上是两个矩阵相乘得到的 变换矩阵 * 投影矩阵 变换矩阵为
{1,    0,    0,    0; <br/>
 0,    1,    0,    0; <br/>
 0,    0,    1,    0; <br/>
 0,    0,   -10,  1;    <br/>
}   <br/>
投影矩阵为</p>

<p>{1,    0,    0,    0; <br/>
 0,    1,    0,    0; <br/>
 0,    0,    1, -0.001; <br/>
 0,    0,    0,    1; <br/>
}   <br/>
上面的两个矩阵相乘则会得到最终的变换矩阵(如果忘记矩阵乘法的可以去看下线性代数复习下)，所以一个矩阵就可以完成变换和投影。
将A点坐标乘上最终的变换矩阵，则得到 {6, 0 , -10, 1.01}, 转换成数学坐标点为 {6/1.01, 0, 10/1.01},则可以知道其在投影平面上的投影点为 {6/1.01, 0, 0} 也就是我们看到的变换后的点。其比之前较靠近原点。越往z轴负方向移动，则在投影平面上越靠近原点。
三.几何解释
将上面的例子使用几何的方式来进行解释分析，当我们沿着y轴的正方向向下看时候，可以得到如下的景象</p>

<p><img src="http://jerryga.github.com/static/7525866072_efebf5cd22.png" alt="" /></p>

<p>虚线为投影线，其和x轴的交点即为A点的投影点。 由相似三角形的定理我们很容易算出投影的点，
1000/(1000 + 10) = x/6,则x = 6*1000/1010 = 6/1.01</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CATransform3D]]></title>
    <link href="http://jerryga.github.com/blog/2013/05/27/catransform3d/"/>
    <updated>2013-05-27T16:25:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/05/27/catransform3d</id>
    <content type="html"><![CDATA[<h3>1 CATransform3D结构成员的意义：</h3>

<p>strct CATransform3D {</p>

<pre><code>CGFloat m11（x缩放）, m12（y切变）, m13（旋转）, m14（）;
CGFloat m21（x切变）, m22（y缩放）, m23（）, m24（）;
CGFloat m31（旋转）, m32（）, m33（）, m34（透视效果，要操作   的这个对象要有旋转的角度，否则没有效果。正直/负值都有意义）;
CGFloat m41（x平移）, m42（y平移）, m43（z平移）, m44（）;
</code></pre>

<p>};</p>

<p>整体比例变换时（m11 == m22），若m33>1,图形整体缩小，若0&lt;m33&lt;1,图形整体放大，若s&lt;0,则发烧关于原点的对称等比变换。</p>

<h3>2 CATransform3DMakeTranslation</h3>

<p>CATransform3DMakeTranslation(0, 0, 0) 创建了一个4*4的单位矩阵。</p>

<h3>3 CATransform3DMakeRotation And CATransform3DRotate</h3>

<h3>4 翻转动画</h3>

<ul>
<li><p>(void)animationCubeRotate:(RotateDirection)directionwithDuration:(float)duration
{
  [CATransaction flush];
  CGFloat height = self.bounds.size.height;
  CABasicAnimation <em>rotation;
  // CABasicAnimation </em>translationX;  // 如果沿X轴翻转,则用不到这个变量.
  CABasicAnimation <em>translationY; // 如果沿Y轴翻转,则用不到这个变量.
  CABasicAnimation </em>translationZ;
  CAAnimationGroup *animationGroup = [CAAnimationGroup animation];
  animationGroup.delegate = self;
  animationGroup.duration = duration;</p>

<p>  if ( direction == RotateFromBottom )
  {</p>

<pre><code>  // 创建(某方向)关键帧动画.
  translationY = [CABasicAnimation animationWithKeyPath:
                  @"sublayerTransform.translation.y"];
  translationY.toValue = [NSNumber numberWithFloat:-(height / 2)];【2】
  rotation = [CABasicAnimation animationWithKeyPath:
              @"sublayerTransform.rotation.x"];
  rotation.toValue = [NSNumber numberWithFloat:D2R(-90.0f)];
</code></pre>

<p>  }
  else if ( direction == RotateFromTop )
  {
  }</p>

<p>  // 处理Z轴
  translationZ = [CABasicAnimation animationWithKeyPath:</p>

<pre><code>              @"sublayerTransform.translation.z"];
</code></pre>

  translationZ.toValue = [NSNumber numberWithFloat:height / 2];【3】
  animationGroup.animations =

<pre><code>  [NSArray arrayWithObjects: rotation, translationY, translationZ, nil];
</code></pre>

<p>  animationGroup.fillMode = kCAFillModeForwards;
  animationGroup.removedOnCompletion = NO;
  [_transformedLayer addAnimation:animationGroup forKey:kAnimationKey];
}</p></li>
</ul>


<p>*针对X轴旋转，就是1，0，0，针对Y轴旋转，就是0，1，0&#8230;下面那行也要进行正确的转换。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Http Test App For Mac]]></title>
    <link href="http://jerryga.github.com/blog/2013/05/24/http-test-app-for-mac/"/>
    <updated>2013-05-24T11:47:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/05/24/http-test-app-for-mac</id>
    <content type="html"><![CDATA[<p><strong>A http app for mac to test http connect</strong></p>

<h1>&#8216;Http&#8217; App Info</h1>

<h2>Version 1.X ????/??/??</h2>

<h3>Description:</h3>

<ul>
<li>HTTP test Client</li>
<li>used for：at least mac os10.7</li>
<li>DownLoad:<a href="https://github.com/jerryga/Http.git">https://github.com/jerryga/Http.git</a></li>
<li>URL：eg：http://www.google.com</li>
<li>Go: start test.</li>
<li>Method: Get/Post
<strong>note</strong>only get and post method，others ,I will update soon.</li>
<li><p>Parameter Type：</p>

<pre><code>            XML：body string format： 
            &lt;?xml version = "1.0" encoding = "UTF-8"?&gt;&lt;id&gt;10002&lt;/id&gt;&lt;name&gt;ga&lt;/name&gt; 
             body type：NSData
            **note**xml version 1.0 encoding UTF-8
             Request Method：Post

            JSON:body string format：{"id":"10002","name":"ga"} 
            body type：NSData
            Request Method：Post

            URLPar:Parameter：url?id=10002&amp;name=ga 
            Request Method：Get **note**the normal method，append parameter after url.
</code></pre></li>
<li><p>T1 table：Add HeadField，for example,content-type、Accept,and so on&#8230;</p></li>
<li><p>T2 table：Add Parameter：</p>

<pre><code>          *1.if you choose ParameterType XML：
          parameter column，Required
          value column：Optional.
          eg1.0：
          parameter   value
          info
          name        ga
          then generate XML format：
           &lt;?xml version = "1.0" encoding = "UTF-8"?&gt;&lt;Info&gt;&lt;name&gt;ga&lt;/name&gt;&lt;/Info&gt; 
          eg1.1：
          parameter column   value column
          info        hello
          name        ga
          then generate XML format：
           &lt;?xml version = "1.0" encoding = "UTF-8"?&gt;&lt;Info&gt;hello&lt;/Info&gt;&lt;name&gt;ga&lt;/name&gt; 
          *2.if you choose ParameterType JSON：
              parameter column，Required
              value column：Optional。
              eg：2.1
          parameter column   value column
          info        hello
          name        ga
          then generate Json format：
           {"name":"ga","Info":"hello"} 
           *3.ParameterType URLPar：No practical significance，but if you choose Get Method, it is Required.
</code></pre></li>
<li><p>Function Button：’+‘、’-‘：add or delete row。</p></li>
<li>R：Result TextView。It will print head fields、result、error、errorCode。</li>
</ul>


<h3>Note</h3>

<ul>
<li>Only for ios http test,  NO Considered web develop and so on&#8230;</li>
<li>Refered for Fetcher.</li>
<li>Copyright © 2013 Jerry GaGa</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OKay]]></title>
    <link href="http://jerryga.github.com/blog/2013/05/23/okay/"/>
    <updated>2013-05-23T19:52:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/05/23/okay</id>
    <content type="html"><![CDATA[<p>This is me~ A Coding Runner</p>

<p><img src="http://jerryga.github.com/static/Ga.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set up Android Environment On Mac]]></title>
    <link href="http://jerryga.github.com/blog/2013/05/23/set-up-android-environment-on-mac/"/>
    <updated>2013-05-23T17:59:00+08:00</updated>
    <id>http://jerryga.github.com/blog/2013/05/23/set-up-android-environment-on-mac</id>
    <content type="html"><![CDATA[<p>Step</p>
]]></content>
  </entry>
  
</feed>
