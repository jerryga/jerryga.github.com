
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>JerryGa's Blog</title>
  <meta name="author" content="JerryGa">

  
  <meta name="description" content="ios7: //viewDidLoad [self prefersStatusBarHidden]; [self performSelector:@selector(setNeedsStatusBarAppearanceUpdate)]; // Add this Method
- (BOOL) &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://jerryga.github.com">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="JerryGa's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">JerryGa's Blog</a></h1>
  
    <h2>Skating In the Rain.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:jerryga.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/26/ios7-statusbarhidden/">Ios7 StatusBarHidden</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-26T15:10:00+08:00" pubdate data-updated="true">Sep 26<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>ios7:</h4>

<pre><code>//viewDidLoad

[self prefersStatusBarHidden];
    [self performSelector:@selector(setNeedsStatusBarAppearanceUpdate)];

// Add this Method
- (BOOL)prefersStatusBarHidden
{
    return YES;
}
</code></pre>

<h4>&lt; ios7</h4>

<pre><code>In info.plist add this key-value:

Key: View controller-based status bar appearance
Value: NO
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/23/ios7/">Ios7</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-23T11:35:00+08:00" pubdate data-updated="true">Sep 23<span>rd</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3><a href="http://onevcat.com/2013/06/developer-should-know-about-ios7/">ios7</a></h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/18/block/">Block</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-18T11:23:00+08:00" pubdate data-updated="true">Sep 18<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/17/apns/">APNS</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-17T17:28:00+08:00" pubdate data-updated="true">Sep 17<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>APNS</h4>

<p><img src="/static/apns.png" alt="" /></p>

<p>生成pem文件：</p>

<pre><code>openssl pkcs12 -clcerts -nokeys -out apns-dev-cert.pem -in apns-dev-cert.p12

openssl pkcs12 -nocerts -out apns-dev-key.pem -in apns-dev-key.p12
</code></pre>

<p>将key和许可文件合成为apns-dev.pem</p>

<pre><code>cat apns-dev-cert.pem apns-dev-key-noenc.pem &gt; apns-dev.pem
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/13/objc-msgsend-vs-performselector/">objc_msgSend() vs performSelector</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-13T15:43:00+08:00" pubdate data-updated="true">Sep 13<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Diff</h4>

<p>两者的主要区别是：objc_msgSend不会通过编译器进行类型检查。在ARC中，如果使用performSelector可能会得到警告</p>

<pre><code>#warning：PerformSelector may cause a leak because its selector is unknown.
</code></pre>

<p>在xcode4.2 LLVM3.0的环境下,可以这样消除警告：</p>

<pre><code>#define SuppressPerformSelectorLeakWarning(Stuff) \
do { \
_Pragma("clang diagnostic push") \
_Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \
Stuff; \
_Pragma("clang diagnostic pop") \
} while (0)
</code></pre>

<p>这样使用：</p>

<pre><code>SuppressPerformSelectorLeakWarning(

            [_target performSelector:_responseSel   withObject:_sectionModel];
    );
</code></pre>

<p>使用objc_msgSend(<em>target, </em>responseSel);虽然也可以消除警告，但是由于objc_msgSend()不会进行类型检查，所以建议尽量不要这样做。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/10/ccprogress/">CCProgress</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-10T15:46:00+08:00" pubdate data-updated="true">Sep 10<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>进度条Progress的使用</h4>

<pre><code>CCSize size = CCDirector::sharedDirector()-&gt;getWinSize();

 CCProgressTo* p1 = CCProgressTo::create(2, 80);
//第一个参数是时间，第二个参数是表示只旋转或者伸长80%
CCSprite *progressSprite = CCSprite::create("RedExpProgressBar.png");
CCProgressTimer* pt = CCProgressTimer::create(progressSprite);
//两种类型kCCProgressTimerTypeRadial和kCCProgressTimerTypeBar
pt-&gt;setType(kCCProgressTimerTypeBar);
pt-&gt;setMidpoint(CCPointMake(0, 0));
pt-&gt;setBarChangeRate(CCPointMake(1, 0));
addChild(pt);
pt-&gt;setPosition(ccp(size.width / 3, size.height / 2));
pt-&gt;runAction(CCRepeatForever::create(p1));
</code></pre>

<p>函数说明：</p>

<p>setMidpoint()函数是设置进度条的起始点，（0,y）表示最左边，（1,,y）表示最右边，（x,1）表示最上面，（x,0）表示最下面。setBarChangeRate()函数是用来设置进度条动画方向的，（1,0）表示横方向，（0,1）表示纵方向。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/09/nsrunloop-and-nsthread/">NSRunLoop and NSThread</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-09-09T16:55:00+08:00" pubdate data-updated="true">Sep 9<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>NSRunLoop的特性：</h4>

<ol>
<li>每个线程都有一个Run Loop，主线程的Run Loop会在App运行时自动运行，子线程中需要手动运行。</li>
<li>每个Run Loop都会以一个模式mode来运行，可以使用NSRunLoop的- (BOOL)runMode:(NSString <em>)mode beforeDate:(NSDate </em>)limitDate 方法运行在某个特定模式mode。</li>
<li>Run Loop的处理两大类事件源：Timer Source和Input Source(包括performSelector***方法簇、Port或者自定义Input Source)，每个事件源都会绑定在Run Loop的某个特定模式mode上，而且只有RunLoop在这个模式运行的时候才会触发该Timer和Input Source。</li>
<li>如果没有任何事件源添加到Run Loop上，Run Loop就会立刻exit。</li>
</ol>


<h4>运行模式Mode</h4>

<ol>
<li>NSDefaultRunLoopMode: 默认的运行模式.</li>
<li>NSRunLoopCommonModes: 是一组常用的模式集合,在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode. <strong><em>注意</em></strong>：让Run Loop运行在NSRunLoopCommonModes下是没有意义的，因为一个时刻Run Loop只能运行在一个特定模式下，而不可能是个模式集合。</li>
<li>UITrackingRunLoopMode: 用于跟踪触摸事件触发的模式（例如UIScrollView上下滚动），主线程当触摸事件触发时会设置为这个模式，可以用来在控件事件触发过程中设置Timer。</li>
<li>GSEventReceiveRunLoopMode: 用于接受系统事件，属于内部的Run Loop模式。</li>
<li>自定义Mode:在coreFoundation中通过CFRunLoopAddCommonMode方法添加自定义Mode到NSRunLoopCommonModes中。</li>
</ol>


<h4>事件源</h4>

<p>两类：Timer Source和Input Source(包括-performSelector:API调用簇，Port Input Source、自定义Input Source)
图表：</p>

<p><img src="/static/runLoop.png" alt="" /></p>

<p>从上图可以看出Run Loop就是处理事件的一个循环，不同的是Timer Source事件处理后不会使Run Loop结束，而Input Source事件处理后会让Run Loop退出。因此你需要自己的一个Loop去不断运行Run Loop来处理事件，就像本文开头的示例那样。</p>

<p>1) Timer Souce就是创建Timer添加到Run Loop中。需要注意的是scheduledTimerWith开头生成的Timer会自动帮你以默认NSDefaultRunLoopMode模式加载到当前的Run Loop中，而其他接口生成的Timer则需要你手动使用-addTimer:forMode添加到Run Loop中。需要额外注意的是Timer的触发不会让Run Loop返回。(Timer sources deliver events to their handler routines but do not cause the run loop to exit.) 。
2) Input Source中的-performSelector:API调用簇方法，有以下这些接口：</p>

<pre><code>performSelectorOnMainThread:withObject:waitUntilDone:
performSelectorOnMainThread:withObject:waitUntilDone:modes:

performSelector:onThread:withObject:waitUntilDone:
performSelector:onThread:withObject:waitUntilDone:modes:

performSelector:withObject:afterDelay:
performSelector:withObject:afterDelay:inModes:

cancelPreviousPerformRequestsWithTarget:
cancelPreviousPerformRequestsWithTarget:selector:object:
</code></pre>

<p>3) Port Input Source：可以用NSMachPort作为线程之间的通讯通道。例如在主线程创建子线程时传入一个NSPort对象，这样主线程就可以和这个子线程通讯啦，如果要实现双向通讯，那么子线程也需要回传给主线程一个NSPort。NSPort的子类除了NSMachPort，还可以使用NSMessagePort或者Core Foundation中的CFMessagePortRef。
注意：虽然有这么棒的方式实现线程间通讯方式，但是估计是由于危及iOS的Sandbox沙盒环境，所以这些API都是私有接口，如果你用到NSPortMessage，XCode会提示&#8217;NSPortMessage&#8217; for instance message is a forward declaration。</p>

<p>4) 自定义Input Source：
向Run Loop添加自定义Input Source只能使用Core Foundation的接口：CFRunLoopSourceCreate创建一个source，CFRunLoopAddSource向Run Loop中添加source，CFRunLoopRemoveSource从Run Loop中删除source，CFRunLoopSourceSignal通知source，CFRunLoopWakeUp唤醒Run Loop。
Apple官方文档提供了一个自定义Input Source使用模式。</p>

<p><img src="/static/runLoop001.png" alt="" /></p>

<p>主线程持有包含子线程的Run Loop和Source的context对象，还有一个用于保存需要运行操作的数据buffer。主线程需要子线程干活时，首先将需要的操作数据添加到数据buffer，然后通知source，唤醒子线程Run Loop（因为子线程可能正在sleep状态，CFRunLoopWakeUp唤醒Run Loop可以通知线程醒来干活），由于子线程也持有这个source和数据buffer，因此在触发唤醒时可以使用这个数据buffer的数据来执行相关操作（需要注意数据buffer访问时的同步）。</p>

<h4>Run Loop的Observer</h4>

<p>Core Foundation层的接口可以定义一个Run Loop的观察者在Run Loop进入以下某个状态时得到通知：</p>

<ol>
<li>Run loop的进入</li>
<li>Run loop处理一个Timer的时刻</li>
<li>Run loop处理一个Input Source的时刻</li>
<li>Run loop进入睡眠的时刻</li>
<li>Run loop被唤醒的时刻，但在唤醒它的事件被处理之前</li>
<li><p>Run loop的终止
Observer的创建以及添加到Run Loop中需要使用Core Foundation的接口：</p>

<pre><code>  CFRunLoopObserverContext  context = {0, (__bridge void *)(self), NULL, NULL, NULL};
  CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopBeforeTimers, YES, 0, &amp;myRunLoopObserver, &amp;context);
  if (observer)
  {
  CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer,
                           kCFRunLoopCommonModes);
                                                          }
</code></pre>

<p>   首先创建Observer的context，然后调用Core Foundation方法CFRunLoopObserverCreate创建Observer，再加入到当前线程的Run Loop中，注意CFRunLoopObserverCreate方法的第二个参数是Observer观察类型，有如下几种：</p>

<pre><code>   /* Run Loop Observer Activities */
   typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
   kCFRunLoopEntry = (1UL &lt;&lt; 0),
   kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),
   kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),
   kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),
   kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),
   kCFRunLoopExit = (1UL &lt;&lt; 7),
   kCFRunLoopAllActivities = 0x0FFFFFFFU
       };
</code></pre></li>
</ol>


<p>对应Run Loop的各种事件，kCFRunLoopAllActivities比较特殊，可以观察所有事件。</p>

<h4>总结</h4>

<p>Run Loop就是一个处理事件源的循环，你可以控制这个Run Loop运行多久，如果当前没有事件发生，Run Loop会让这个线程进入睡眠状态(避免再浪费CPU时间)，如果有事件发生，Run Loop就处理这个事件。Run Loop处理事件和发送给Observer通知的流程如下：</p>

<ol>
<li>进入Run Loop运行，此时会通知观察者进入Run Loop；</li>
<li>如果有Timer即将触发时，通知观察者；</li>
<li>如果有非Port的Input Sourc即将e触发时，通知观察者；</li>
<li>触发非Port的Input Source事件源；</li>
<li>如果基于Port的Input Source事件源即将触发时，立即处理该事件，跳转到步骤9；</li>
<li>通知观察者当前线程将进入休眠状态；</li>
<li>将线程进入休眠状态直到有以下事件发生：基于Port的Input Source被触发、Timer被触发、Run Loop运行时间到了过期时间、Run Loop被唤醒。</li>
<li>通知观察者线程将要被唤醒。</li>
<li>处理被触发的事件：
如果是用户自定义的Timer，处理Timer事件后重新启动Run Loop进入步骤2；
如果线程被唤醒又没有到过期时间，则进入步骤2；
如果是其他Input Source事件源有事件发生，直接处理这个事件；</li>
<li>到达此步骤说明Run Loop运行时间到期，或者是非Timer的Input Source事件被处理后，Run Loop将要退出，退出前通知观察者线程已退出。</li>
</ol>


<p>什么时候需要用到Run Loop？官方文档的建议是：</p>

<ol>
<li>需要使用Port或者自定义Input Source与其他线程进行通讯。</li>
<li>需要在线程中使用Timer。</li>
<li>需要在线程上使用performSelector方法。</li>
<li>需要让线程执行周期性的工作。</li>
<li>我个人在开发中遇到的需要使用Run Loop的情况有：</li>
<li>使用自定义Input Source和其他线程通信</li>
<li>子线程中使用了定时器</li>
<li>使用任何performSelector到子线程中运行方法</li>
<li>使用子线程去执行周期性任务</li>
<li>NSURLConnection在子线程中发起异步请求</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/30/gcd/">GCD</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-30T11:25:00+08:00" pubdate data-updated="true">Aug 30<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>What is GCD?</h3>

<p>Grand Central Dispatch 简称为GCD，这是一套底层api，提供了一种新的方法来进行并发程序编写。类似于NSOperationQueue，允许程序将多个任务切分为多个单一任务然后提交到工作队列来并发地或者串行地执行。GCD相对于NSOperationQueue更底层，更高效，并且它不是Cocoa框架的一部分。</p>

<h3>GCD的功能如下：</h3>

<ol>
<li>正如开头所说，GCD允许将多个任务切分为多个单一任务并发或者串行地执行。这个应该是使用GCD最多的地方。</li>
<li>可以设置句柄来响应文件描述符。（如可以通过GCD来读取文件，并获得读取进度，这个在JerryGa的github有相关Demo）</li>
<li>可以通过mach ports来进行进程间的通讯。</li>
<li>计时器、信号量、用户生成事件。</li>
</ol>


<h3>GCD的优势：</h3>

<ol>
<li><strong><em>简单易用</em></strong>。由于GCD基于work unit而非像thread那样基于运算，所以GCD可以控制诸如等待任务结束、监视文件描述符、周期执行代码以及工作挂起等任务。基于block的血统导致它能极为简单得在不同代码作用域之间传递上下文。</li>
<li><strong><em>效率</em></strong>: GCD被实现得如此轻量和优雅，使得它在很多地方比之专门创建消耗资源的线程更实用且快速。这关系到易用性：导致GCD易用的原因有一部分在于你可以不用担心太多的效率问题而仅仅使用它就行了。</li>
<li><strong><em>性能</em></strong>: GCD自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。</li>
</ol>


<h3>Dispatch Objects</h3>

<p>Dispatch Object也是使用引用计数的，使用dispatch_release和dispatch_retain函数来操作dispatch object进行内存管理。但是dispatch不参与垃圾回收机制（ARC）。</p>

<h3>Dispatch Queues</h3>

<p>并行概念：同一时间执行多个不同任务。
串行概念：同一时间只能执行单一任务。</p>

<p>GCD有三种队列：</p>

<ol>
<li>main queue:串行队列。提交到此queue的任务会在主线程中执行。使用dispatch_get_main_queue()来获取.</li>
<li><p>global queue：全局队列。是并发队列。有三个优先级：</p>

<pre><code>DISPATCH_QUEUE_PRIORITY_HIGH 2 //最高
DISPATCH_QUEUE_PRIORITY_DEFAULT 0 //默认
DISPATCH_QUEUE_PRIORITY_LOW (-2) //低级
DISPATCH_QUEUE_PRIORITY_BACKGROUND           INT16_MIN( Available in iOS 5.0 and later.)//某些磁盘读写操作可以设置此优先级。
</code></pre>

<p> 获取全局队列代码如下：                                       dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p></li>
<li><p>自己创建的队列。有两方式：串行、并行。串行可以用来实现同步机制，类似线程锁。EG：</p>

<p> <strong><em>串行</em></strong></p>

<pre><code>DISPATCH_QUEUE_SERIAL FIFO
dispatch_queue_t serialQueue =   dispatch_queue_create("com.Test.gcd", DISPATCH_QUEUE_SERIAL);

dispatch_async(serialQueue, ^{
 NSLog(@"Task1*** ");
 });

 dispatch_async(serialQueue, ^{
 NSLog(@"Task2***");
 });
dispatch_async(serialQueue, ^{
 NSLog(@"Task3*** ");
 });
</code></pre>

<p>测试输出结果如下：</p>

<pre><code>  2013-08-30 12:20:19.684 GCDTestPro[3882:1303] Task1*** 
  2013-08-30 12:20:19.685 GCDTestPro[3882:1303] Task2***
  2013-08-30 12:20:19.686 GCDTestPro[3882:1303] Task3***
</code></pre>

<p>  <strong><em>并行</em></strong></p>

<pre><code>DISPATCH_QUEUE_CONCURRENT

  dispatch_queue_t asyQueue = dispatch_queue_create("com.Test.gcd", DISPATCH_QUEUE_CONCURRENT);

  dispatch_async(asyQueue, ^{
  NSLog(@"Task1*** ");
  });
  dispatch_async(asyQueue, ^{
  NSLog(@"Task2***");
  });
  dispatch_async(asyQueue, ^{
  NSLog(@"Task3*** ");
  });
</code></pre>

<p>测试输出结果如下：</p>

<pre><code>2013-08-30 12:27:34.523 GCDTestPro[4043:1b03] Task2***
2013-08-30 12:27:34.523 GCDTestPro[4043:1303] Task1*** 
2013-08-30 12:27:34.523 GCDTestPro[4043:3d13] Task3*** 
</code></pre></li>
</ol>


<p>从测试结果可以看出：串行队列是同步机制。按照先入先出的原则依顺序执行。而异步队列的执行顺序是无序的。所以，对于自定义队列有两种：FIFO、ASY，由创建队列时的dispatch_queue_attr_t决定。注意：DISPATCH_QUEUE_CONCURRENT是在4.3以后才可以使用。</p>

<h3>锁</h3>

<p>使用GCD的同步机制可以用来代替传统多线程编程中的Lock。</p>

<p>eg：
传统编程中我们可能这样做：</p>

<pre><code>- (void)setStatus:(Status)status {
@synchronized(self) {
    _status = status;
}
}
</code></pre>

<p>或者：</p>

<pre><code>- (void)setStatus:(Status)status {
[_lock lock];
_status = status;
[_lock unlock];
}
</code></pre>

<p>用GCD来代替：</p>

<pre><code>- (void)setStatus:(Status)status {
dispatch_sync(_lockQueue, ^{
    _status = status;
}
}

- (void)setStatus:(Status)status {
dispatch_async(_lockQueue, ^{
    _status = status;
}
}
</code></pre>

<p>async是异步处理
sync 是同步处理，可以从 传统的 “互斥” 来理解。因为在设置obj的时候，可能有一大堆数据需要运算赋值，所以异步执行。</p>

<h3>终止Queue</h3>

<p>在GCD API中，并没有提供真正的cancel当前queue的功能（如果想得到更多的queue的控制权，建议用NSOperationQueue） ，在api中有dispatch_suspend（）函数（必须和dispatch_resume调用次数一致），这个函数是挂起queue，提交到queue的block可能已经执行了，在调用dispatch_suspend（）之前，所以dispatch_suspend（）并不能起到cancel当前正在运行task的作用。</p>

<p>现提供一种方法来cancel正在运行的task的方式：</p>

<pre><code>#import "GCDManager.h"

@interface GCDManager ()
{
    BOOL isCanceled;
    dispatch_queue_t myQueue;
}
@end

@implementation GCDManager

- (void) cancelCurrentGCD {
isCanceled = YES;
}

- (id)init {
    if (self = [super init]) {
        isCanceled = NO;
        myQueue = 
    dispatch_queue_create("com.GCDTestPro.myQueue",             DISPATCH_QUEUE_SERIAL);
    }
    return self;
}

- (void)doSomeWorkOnGCD {
    dispatch_async(myQueue, ^{
        for (int i = 0; i &lt; 1000; ++i) {
            if (!isCanceled) {
                NSLog(@"i %d",i);
            }
        }
    });
}

- (void)dealloc {
    dispatch_release(myQueue);
    [super dealloc];
}
</code></pre>

<p>测试用例：</p>

<pre><code>GCDManager *manager = [[GCDManager alloc] init];
[manager doSomeWorkOnGCD];
[manager performSelector:@selector(cancelCurrentGCD) withObject:nil afterDelay:0.5];
[manager release];
</code></pre>

<p>测试结果：</p>

<pre><code>2013-09-03 16:24:25.139 GCDTestPro[6066:1303] i 0
                    ……
2013-09-03 16:24:25.638 GCDTestPro[6066:1303] i 607
2013-09-03 16:24:25.638 GCDTestPro[6066:1303] i 608
2013-09-03 16:24:25.639 GCDTestPro[6066:1303] i 609
2013-09-03 16:24:25.639 GCDTestPro[6066:1303] i 610
2013-09-03 16:24:25.639 GCDTestPro[6066:1303] i 611
</code></pre>

<p>结果说明：</p>

<p>可以看出，在延迟0.5s之后，task就终止到了i=611的时候。如果不调用
cancelCurrentGCD，那会一直到i=999，task才回终止。</p>

<h3>Dispatch group</h3>

<p>dispatch group可以将多个要执行的block封装成一组，当这些block完成时，监测到发出的消息。</p>

<p>测试用例：</p>

<pre><code>dispatch_group_t group = dispatch_group_create();

dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 1");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 2");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 3");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 4");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 5");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 6");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 7");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 8");
});
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

NSLog(@"All task in queue finished");
</code></pre>

<p>输出结果：</p>

<pre><code>2013-09-04 10:45:49.213 GCDTestPro[958:1c03] This is Task 2
2013-09-04 10:45:49.213 GCDTestPro[958:1e03] This is Task 3
2013-09-04 10:45:49.213 GCDTestPro[958:4103] This is Task 4
2013-09-04 10:45:49.213 GCDTestPro[958:1303] This is Task 1
2013-09-04 10:45:49.216 GCDTestPro[958:1c03] This is Task 5
2013-09-04 10:45:49.216 GCDTestPro[958:1e03] This is Task 6
2013-09-04 10:45:49.216 GCDTestPro[958:4103] This is Task 7
2013-09-04 10:45:49.216 GCDTestPro[958:1303] This is Task 8
2013-09-04 10:45:49.218 GCDTestPro[958:c07] All task in queue finished
</code></pre>

<p>这样的话，一直会等到在group中的所有task执行完，会阻塞当前thread。api提供了相关方法来代替此种方式：dispatch_group_notify</p>

<p>测试用例：</p>

<pre><code>dispatch_group_t group = dispatch_group_create();
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 1");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 2");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 3");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 4");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 5");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 6");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 7");
});
dispatch_group_async(group, queue, ^{
    NSLog(@"This is Task 8");
});
dispatch_group_notify(group, queue, ^{
    NSLog(@"All task in queue finished");
});
NSLog(@"I am out of group");
</code></pre>

<p>输出结果：</p>

<pre><code>2013-09-04 10:51:34.256 GCDTestPro[1044:c07] I am out of group
2013-09-04 10:51:34.256 GCDTestPro[1044:1303] This is Task 1
2013-09-04 10:51:34.257 GCDTestPro[1044:3d13] This is Task 3
2013-09-04 10:51:34.256 GCDTestPro[1044:1b03] This is Task 2
2013-09-04 10:51:34.257 GCDTestPro[1044:4003] This is Task 4
2013-09-04 10:51:34.260 GCDTestPro[1044:4103] This is Task 5    
2013-09-04 10:51:34.261 GCDTestPro[1044:1303] This is Task 6
2013-09-04 10:51:34.261 GCDTestPro[1044:4303] This is Task 7
2013-09-04 10:51:34.262 GCDTestPro[1044:4403] This is Task 8
2013-09-04 10:51:34.267 GCDTestPro[1044:4403] All task in queue finished
</code></pre>

<h4>Dispatch_group_enter的使用：</h4>

<pre><code>dispatch_group_t group = dispatch_group_create();

MyCoreDataObject *coreDataObject;

dispatch_group_enter(group);
AFHTTPRequestOperation *operation1 =    [[AFHTTPRequestOperation alloc] initWithRequest:request1];
[operation1 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
coreDataObject.attribute1 = responseObject;
sleep(5);
dispatch_group_leave(group);
}];
[operation1 start];

dispatch_group_enter(group);
AFHTTPRequestOperation *operation2 = [[AFHTTPRequestOperation alloc] initWithRequest:request1];
[operation2 setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
coreDataObject.attribute2 = responseObject;
sleep(10);
dispatch_group_leave(group);
}];
[operation2 start];

dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);

[context save:nil];
</code></pre>

<h3>Dispatch_apply</h3>

<p>定义：</p>

<pre><code>dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));
</code></pre>

<p>参数 iterations 表示迭代的次数，void (<sup>block)(size_t)</sup> 是 block 循环体。</p>

<p>Des：调用单一block多次，并平行运算，然后等待所有运算结束</p>

<p>测试用例：</p>

<pre><code>   NSMutableArray *testArray = [[NSMutableArray alloc] init];
for (int i = 0; i &lt; 10; ++i) {
    [testArray addObject:[NSString stringWithFormat:@"%d",i]];
}
int count = [testArray count];
__block int sum = 0;
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
    sum += [[testArray objectAtIndex:i] integerValue];
    NSLog(@"sum is %d",sum);
});
NSLog(@"I am out of apply");
</code></pre>

<p>测试结果：</p>

<pre><code>2013-09-05 10:06:28.285 GCDTestPro[738:1b03] sum is 1
2013-09-05 10:06:28.285 GCDTestPro[738:4003] sum is 4
2013-09-05 10:06:28.285 GCDTestPro[738:1303] sum is 1
2013-09-05 10:06:28.285 GCDTestPro[738:c07] sum is 6
2013-09-05 10:06:28.287 GCDTestPro[738:1b03] sum is 10
2013-09-05 10:06:28.287 GCDTestPro[738:4003] sum is 15
2013-09-05 10:06:28.287 GCDTestPro[738:c07] sum is 28
2013-09-05 10:06:28.287 GCDTestPro[738:1303] sum is 21
2013-09-05 10:06:28.289 GCDTestPro[738:1b03] sum is 36
2013-09-05 10:06:28.289 GCDTestPro[738:4003] sum is 45
2013-09-05 10:06:28.290 GCDTestPro[738:c07] I am out of apply
</code></pre>

<p>从测试结果可以看出，对于sum的操作是并行运算的。而用for循环测用例以及测试结果如下：</p>

<pre><code> NSMutableArray *testArray = [[NSMutableArray alloc] init];
for (int i = 0; i &lt; 10; ++i) {
    [testArray addObject:[NSString stringWithFormat:@"%d",i]];
}
int count = [testArray count];
int sum = 0;
for (int i = 0; i &lt; count; ++i) {
    sum += [[testArray objectAtIndex:i] integerValue];
    NSLog(@"sum is %d",sum);
}
NSLog(@"I am out of for loop");
</code></pre>

<p>测试结果:</p>

<pre><code>2013-09-05 10:10:02.770 GCDTestPro[783:c07] sum is 0
2013-09-05 10:10:02.771 GCDTestPro[783:c07] sum is 1
2013-09-05 10:10:02.771 GCDTestPro[783:c07] sum is 3
2013-09-05 10:10:02.771 GCDTestPro[783:c07] sum is 6
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 10
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 15
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 21
2013-09-05 10:10:02.772 GCDTestPro[783:c07] sum is 28
2013-09-05 10:10:02.773 GCDTestPro[783:c07] sum is 36
2013-09-05 10:10:02.773 GCDTestPro[783:c07] sum is 45
2013-09-05 10:10:02.773 GCDTestPro[783:c07] I am out of for loop
</code></pre>

<p><strong><em>需要明智地使用这项技术，因为dispatch queue的开销虽然非常小，但仍然存在，循环代码必须拥有足够的工作量，才能忽略掉dispatch queue的这些开销。</em></strong></p>

<p>因为dispatch_apply会阻塞当前线程，如果想要在后台运行，用dispatch_async提交到queue即可：</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_async(queue, ^{
    dispatch_apply(count, queue, ^(size_t i) {
        sum += [[testArray objectAtIndex:i] integerValue];
        NSLog(@"sum is %d",sum);
    });
});
</code></pre>

<h3>Dispatch Source</h3>

<p>dispatch source就像&#8221;WatchDog&#8221;，监视某些事件，当事件发生时，自动将一个block放入一个queue队列中执行。</p>

<p>事件类型：</p>

<pre><code> *  DISPATCH_SOURCE_TYPE_DATA_ADD:        n/a
 *  DISPATCH_SOURCE_TYPE_DATA_OR:         n/a
 *  DISPATCH_SOURCE_TYPE_MACH_SEND:       mach port (mach_port_t)
 *  DISPATCH_SOURCE_TYPE_MACH_RECV:       mach port (mach_port_t)
 *  DISPATCH_SOURCE_TYPE_PROC:            process identifier (pid_t)
 *  DISPATCH_SOURCE_TYPE_READ:            file descriptor (int)
 *  DISPATCH_SOURCE_TYPE_SIGNAL:          signal number (int)
 *  DISPATCH_SOURCE_TYPE_TIMER:           n/a
 *  DISPATCH_SOURCE_TYPE_VNODE:           file descriptor (int)
 *  DISPATCH_SOURCE_TYPE_WRITE:           file descriptor (int)
</code></pre>

<p>Example：</p>

<p>计时器类型：（DISPATCH_SOURCE_TYPE_TIMER）</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(
                                DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    // create our timer source
   dispatch_source_t _timer = dispatch_source_create(
                       DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
                       queue);

    // set the time to fire (we're only going to fire once,
    // so just fill in the initial time).
    dispatch_source_set_timer(_timer,
           dispatch_time(DISPATCH_TIME_NOW, timeout * NSEC_PER_SEC),
           DISPATCH_TIME_FOREVER, 0);

    // Hey, let's actually do something when the timer fires!
    dispatch_source_set_event_handler(_timer, ^{
        NSLog(@"WATCHDOG: task took longer than %f seconds",
                timeout);
        // ensure we never fire again
        dispatch_source_cancel(_timer);
    });

    // now that our timer is all set to go, start it
    dispatch_resume(_timer);
</code></pre>

<p>读取文件类型：（DISPATCH_SOURCE_TYPE_READ）</p>

<pre><code> const char* fileName = [[[NSBundle mainBundle] pathForResource:@"Test" ofType:@"txt"] UTF8String];
int fd = open(fileName, O_NONBLOCK|O_RDONLY);    //设置type为读取
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, fd, 0, dispatch_get_main_queue());

dispatch_source_set_event_handler(source, ^{
    //每次读取的buffer
    char buffer[1024];
    //余下的size
    size_t estimatedLength = dispatch_source_get_data(source);
    //读取size
    ssize_t bytesRead = read(fd, buffer, MIN(1024, estimatedLength));
    if (bytesRead &lt; 0) {
        if (errno != EAGAIN) {
            printf("Unexpected error!");
            abort();
        }
    } else if (bytesRead &gt; 0) {
        printf("Got %ld bytes of data.%ld\n", bytesRead,estimatedLength);
    } else {
        printf("EOF encountered!\n");
        dispatch_source_cancel(source);
    }
});

dispatch_source_set_cancel_handler(source, ^{
    printf("Cancel handler was called.\n");
    close(fd);
    dispatch_release(source);
});

dispatch_resume(source);
</code></pre>

<p>事件联结：</p>

<pre><code>dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue());
dispatch_source_set_event_handler(source, ^{
    [progressIndicator incrementBy:dispatch_source_get_data(source)];
});
dispatch_resume(source);

dispatch_apply([array count], globalQueue, ^(size_t index) {
    // do some work on data at index
    dispatch_source_merge_data(source, 1);
});
    dispatch_resume(source);
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/30/markdownyu-fa-shuo-ming/">MarkDown语法说明</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-30T11:12:00+08:00" pubdate data-updated="true">Aug 30<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Link: <a href="http://wowubuntu.com/markdown/#overview">markDown</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/29/ruby-log/">Ruby Log</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-29T23:11:00+08:00" pubdate data-updated="true">Aug 29<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>markdown语法快速成文，git与github实时保存，jekyll或octopress实时成书或者showoff实时成ppt。入门略有门槛，但是习惯了，写作效率会好很多。以下以octopress为例，进行说明。</h3>

<h2>配置个人github账号:</h2>

<h3>登陆github，创建一个个人账号。假设叫做：rubyonchina。</h3>

<h3>然后回到ubuntu或者Mac里面，仍然是在终端里面，输入：</h3>

<h3>[[ -f ~/.ssh/id_rsa.pub ]] || ssh-keygen -t rsa</h3>

<h3>按照默认提示一路确认，生成密钥之后，将生成的信息复制到github页面中，如下所示：[[ -f ~/.ssh/id_rsa.pub ]] &amp;&amp; cat ~/.ssh/id_rsa.pub | xclip</h3>

<h3>然后在浏览器中打开页面：</h3>

<h3>https://github.com/account/ssh</h3>

<h3>点击，Add another public key，粘贴前面步骤复制的信息，请格外注意，不要在Title中填写内容，直接将复制的内容粘贴到Key中，然后点击：Add Key即可。</h3>

<h2>配置octopress个人博客</h2>

<h3>cd ~/dev/</h3>

<h3>git clone git://github.com/imathis/octopress.git rubyonchina.github.com</h3>

<h3>cd ~/dev/rubyonchina.github.com</h3>

<h3>修改默认的.rvmrc文件的内容为：</h3>

<h3>rvm use 1.9.2@rails31</h3>

<h3>安装相应的gem:</h3>

<h3>bundle update</h3>

<h3>然后生成模版文件：</h3>

<h3>rake install</h3>

<h2>分发到github上。</h2>

<h3>分发之前，假设你已经注册用户名为rubyonchina的github.com账号，已经创建名为rubyonchina.github.com项目。</h3>

<h3>cd ~/dev/rubyonchina.github.com</h3>

<h3>git remote add rubyonchina git@github.com:rubyonchina/rubyonchina.github.com.git</h3>

<h2>新增一篇测试博客：</h2>

<h3>rake new_post[&#8220;post title&#8221;]</h3>

<h3>生成静态站点：</h3>

<h3>rake generate</h3>

<h3>配置octopress与github的连接：</h3>

<h3>rake setup_github_pages</h3>

<h3>按照提示填入你的github项目网址，比如，本示例是：</h3>

<h3>git@github.com:rubyonchina/rubyonchina.github.com.git</h3>

<h3>分发到github上：</h3>

<h3>rake deploy</h3>

<h3>第一次运行时，会询问是否建立对github的授权，输入：yes。然后将站点更新的内容推送到github上。</h3>

<h3>git push -u rubyonchina master</h3>

<h3>尝试浏览，</h3>

<h3>http://rubyonchina.github.com</h3>

<h3>OK！成功！然后，此时，再创建一个新的github的source分支，用于保存写作的md源文件等。</h3>

<h3>git add .</h3>

<h3>git commit -m &#8220;some changes&#8221;</h3>

<h3>git push rubyonchina source</h3>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/09/26/ios7-statusbarhidden/">ios7 StatusBarHidden</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/23/ios7/">ios7</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/18/block/">Block</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/17/apns/">APNS</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/13/objc-msgsend-vs-performselector/">objc_msgSend() VS performSelector</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - JerryGa -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
